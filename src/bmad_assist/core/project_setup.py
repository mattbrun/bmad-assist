"""Project setup utilities for bmad-assist.

Provides shared logic for init and run commands to copy bundled workflows
to the project directory and manage gitignore warnings.
"""

import logging
import os
import sys
from dataclasses import dataclass, field
from difflib import unified_diff
from enum import Enum
from pathlib import Path

from rich.console import Console
from rich.prompt import Prompt

from bmad_assist.core.config import Config
from bmad_assist.core.exceptions import BmadAssistError
from bmad_assist.git import check_gitignore

logger = logging.getLogger(__name__)


class SetupError(BmadAssistError):
    """Error during project setup."""


class OverwriteDecision(Enum):
    """User's decision for handling differing files."""

    ALL = "a"
    SKIP = "s"
    INTERACTIVE = "i"
    SHOW_DIFF = "d"


@dataclass
class CopyResult:
    """Result of copying bundled workflows."""

    copied: list[str] = field(default_factory=list)
    skipped: list[str] = field(default_factory=list)
    unchanged: list[str] = field(default_factory=list)


@dataclass
class SetupResult:
    """Result of project setup operation."""

    dirs_created: list[Path] = field(default_factory=list)
    config_created: bool = False
    workflows_copied: list[str] = field(default_factory=list)
    workflows_skipped: list[str] = field(default_factory=list)
    gitignore_updated: bool = False

    @property
    def has_skipped(self) -> bool:
        """Return True if any workflows were skipped due to differences."""
        return len(self.workflows_skipped) > 0


# Default BMAD config template for bundled workflows
_DEFAULT_BMAD_CONFIG = """\
# BMM Module Configuration
# Generated by bmad-assist
# This minimal config enables bundled workflows without full BMAD installation

project_name: {project_name}
user_name: User
communication_language: English
document_output_language: English
user_skill_level: expert

# Path configuration
output_folder: "{{project-root}}/_bmad-output"
planning_artifacts: "{{project-root}}/_bmad-output/planning-artifacts"
implementation_artifacts: "{{project-root}}/_bmad-output/implementation-artifacts"
project_knowledge: "{{project-root}}/docs"
"""


def _validate_path_safe(base_path: Path, target_path: Path) -> bool:
    """Ensure target_path is within base_path (no traversal).

    Args:
        base_path: The base directory that target must be within.
        target_path: The path to validate.

    Returns:
        True if target_path is safely within base_path.

    """
    try:
        base_resolved = base_path.resolve()
        target_resolved = target_path.resolve()
        return target_resolved.is_relative_to(base_resolved)
    except (ValueError, OSError):
        return False


def _compare_files(file1: Path, file2: Path) -> bool:
    """Return True if files are identical (normalized).

    Handles CRLF normalization and binary files.
    Does NOT follow symlinks (F5-SEC fix).

    Args:
        file1: First file to compare.
        file2: Second file to compare.

    Returns:
        True if files have identical content (after normalization).

    """
    # Don't compare symlinks - always treat as different
    if file1.is_symlink() or file2.is_symlink():
        return False

    try:
        content1 = file1.read_text(encoding="utf-8").replace("\r\n", "\n").rstrip()
        content2 = file2.read_text(encoding="utf-8").replace("\r\n", "\n").rstrip()
        return content1 == content2
    except UnicodeDecodeError:
        # Binary file - byte comparison (F7-SEC: explicit binary path)
        return file1.read_bytes() == file2.read_bytes()


def _show_diff(src: Path, dst: Path, console: Console) -> None:
    """Display unified diff between two files.

    Args:
        src: Source (bundled) file.
        dst: Destination (local) file.
        console: Rich console for output.

    """
    try:
        src_lines = src.read_text(encoding="utf-8").splitlines(keepends=True)
        dst_lines = dst.read_text(encoding="utf-8").splitlines(keepends=True)

        diff = unified_diff(
            dst_lines,
            src_lines,
            fromfile=f"local/{dst.name}",
            tofile=f"bundled/{src.name}",
            lineterm="",
        )
        diff_text = "".join(diff)

        if diff_text:
            console.print("\n[bold]Diff (local → bundled):[/bold]")
            # Colorize diff output
            for line in diff_text.split("\n"):
                if line.startswith("+") and not line.startswith("+++"):
                    console.print(f"[green]{line}[/green]")
                elif line.startswith("-") and not line.startswith("---"):
                    console.print(f"[red]{line}[/red]")
                elif line.startswith("@@"):
                    console.print(f"[cyan]{line}[/cyan]")
                else:
                    console.print(line)
            console.print()
        else:
            console.print("[dim]Files are identical after normalization[/dim]")
    except Exception as e:
        console.print(f"[red]Could not show diff: {e}[/red]")


def _show_help(console: Console) -> None:
    """Display help for prompt options."""
    console.print("\n[bold]Options:[/bold]")
    console.print("  [a] Overwrite ALL - replace all differing files with bundled versions")
    console.print("  [s] Skip all     - keep your local versions (default)")
    console.print("  [i] Interactive  - prompt for each file individually")
    console.print("  [d] Show diff    - display differences, then prompt again")
    console.print("  [?] Help         - show this message\n")


def _prompt_overwrite_batch(
    differing_files: list[tuple[Path, Path]],
    console: Console,
) -> OverwriteDecision:
    """Prompt user for batch overwrite decision.

    Handles non-TTY gracefully (F4-IMPL fix).

    Args:
        differing_files: List of (src, dst) tuples for differing files.
        console: Rich console for output.

    Returns:
        User's decision for handling differing files.

    """
    if not sys.stdin.isatty():
        console.print("[yellow]Non-interactive mode: skipping differing files[/yellow]")
        return OverwriteDecision.SKIP

    count = len(differing_files)
    console.print(f"\n[yellow]{count} workflow file(s) differ from bundled version:[/yellow]")
    for _src, dst in differing_files[:5]:  # Show first 5
        try:
            rel_path: Path | str = dst.relative_to(dst.parent.parent.parent.parent)
        except ValueError:
            rel_path = dst.name
        console.print(f"  - {rel_path}")
    if count > 5:
        console.print(f"  ... and {count - 5} more")

    while True:
        choice = Prompt.ask(
            "\nWhat would you like to do?",
            choices=["a", "s", "i", "d", "?"],
            default="s",
        )
        if choice == "?":
            _show_help(console)
            continue
        if choice == "d":
            # Show diff for first file, then re-prompt
            src, dst = differing_files[0]
            if len(differing_files) > 1:
                console.print(f"[dim](Showing first of {len(differing_files)} files. Use [i] for per-file diffs.)[/dim]") # noqa: E501
            _show_diff(src, dst, console)
            continue
        return OverwriteDecision(choice)


def _prompt_overwrite_single(
    src: Path,
    dst: Path,
    console: Console,
) -> bool:
    """Prompt for single file overwrite. Returns True to overwrite.

    Args:
        src: Source (bundled) file.
        dst: Destination (local) file.
        console: Rich console for output.

    Returns:
        True if user wants to overwrite, False to skip.

    """
    try:
        rel_path: Path | str = dst.relative_to(dst.parent.parent.parent.parent)
    except ValueError:
        rel_path = dst.name

    while True:
        choice = Prompt.ask(
            f"Overwrite {rel_path}?",
            choices=["y", "n", "d", "?"],
            default="n",
        )
        if choice == "?":
            console.print("  [y] Yes - overwrite with bundled version")
            console.print("  [n] No  - keep local version (default)")
            console.print("  [d] Diff - show differences")
            continue
        if choice == "d":
            _show_diff(src, dst, console)
            continue
        return choice == "y"


def _atomic_copy_file(src: Path, dst: Path) -> None:
    """Copy file atomically with secure temp file permissions.

    Args:
        src: Source file to copy.
        dst: Destination path.

    Raises:
        SetupError: If copy fails or source is a symlink.

    """
    dst.parent.mkdir(parents=True, exist_ok=True)
    temp_path = dst.with_suffix(dst.suffix + ".tmp")

    try:
        # Read source (don't follow symlinks - F5-SEC)
        if src.is_symlink():
            raise SetupError(f"Cannot copy symlink: {src}")
        content = src.read_bytes()

        # Write to temp with standard permissions (readable by group/other)
        fd = os.open(temp_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o644)
        try:
            os.write(fd, content)
        finally:
            os.close(fd)

        # Atomic replace
        os.replace(temp_path, dst)
    except OSError as e:
        if temp_path.exists():
            temp_path.unlink()
        raise SetupError(f"Failed to copy {src} to {dst}: {e}") from e


def _copy_workflow_tree(src_dir: Path, dst_dir: Path, _is_root: bool = True) -> None:
    """Copy entire workflow directory tree with rollback on failure.

    Args:
        src_dir: Source workflow directory.
        dst_dir: Destination workflow directory.
        _is_root: Internal flag - True for top-level call (enables rollback).

    Raises:
        SetupError: If any copy operation fails. Cleans up partial copy.

    """
    import shutil

    created_dst = not dst_dir.exists()
    dst_dir.mkdir(parents=True, exist_ok=True)

    try:
        for item in src_dir.iterdir():
            if item.is_symlink():
                logger.warning("Skipping symlink in workflow: %s", item)
                continue
            if item.is_dir():
                _copy_workflow_tree(item, dst_dir / item.name, _is_root=False)
            else:
                _atomic_copy_file(item, dst_dir / item.name)
    except (SetupError, OSError) as e:
        # Rollback: remove partially copied directory (only at root level)
        if _is_root and created_dst and dst_dir.exists():
            logger.warning("Rolling back partial copy: %s", dst_dir)
            shutil.rmtree(dst_dir, ignore_errors=True)
        raise SetupError(f"Failed to copy workflow tree {src_dir}: {e}") from e


def _workflow_dirs_identical(src_dir: Path, dst_dir: Path) -> bool:
    """Check if two workflow directories have identical content.

    Args:
        src_dir: Source workflow directory.
        dst_dir: Destination workflow directory.

    Returns:
        True if all files are identical.

    """
    if not dst_dir.exists():
        return False

    for src_file in src_dir.rglob("*"):
        if src_file.is_dir():
            continue
        if src_file.is_symlink():
            return False  # Symlinks always different

        rel_path = src_file.relative_to(src_dir)
        dst_file = dst_dir / rel_path

        if not dst_file.exists():
            return False
        if not _compare_files(src_file, dst_file):
            return False

    return True


def _collect_differing_files(
    src_dir: Path, dst_dir: Path
) -> list[tuple[Path, Path]]:
    """Collect all files that differ between source and destination.

    Args:
        src_dir: Source workflow directory.
        dst_dir: Destination workflow directory.

    Returns:
        List of (src_file, dst_file) tuples for differing files.

    """
    differing = []

    for src_file in src_dir.rglob("*"):
        if src_file.is_dir():
            continue

        rel_path = src_file.relative_to(src_dir)
        dst_file = dst_dir / rel_path

        if dst_file.exists() and not _compare_files(src_file, dst_file):
            differing.append((src_file, dst_file))

    return differing


def _create_bmad_config(project_path: Path, console: Console) -> bool:
    """Create BMAD config if it doesn't exist. Returns True if created.

    Args:
        project_path: Project root directory.
        console: Rich console for output.

    Returns:
        True if config was created, False if already exists.

    """
    config_dir = project_path / "_bmad" / "bmm"
    config_file = config_dir / "config.yaml"

    if config_file.exists():
        return False

    config_dir.mkdir(parents=True, exist_ok=True)
    content = _DEFAULT_BMAD_CONFIG.format(project_name=project_path.name)
    config_file.write_text(content, encoding="utf-8")
    console.print(f"  [green]Created:[/green] {config_file.relative_to(project_path)}")
    return True


def check_gitignore_warning(
    project_path: Path,
    config: Config | None,
    console: Console,
) -> None:
    """Show gitignore warning if needed, respecting suppress config.

    Args:
        project_path: Project root directory.
        config: Loaded config (may be None).
        console: Rich console for output.

    """
    if config and config.warnings and config.warnings.suppress_gitignore:
        return  # Suppressed

    all_present, missing = check_gitignore(project_path)
    if all_present:
        return

    console.print("\n[yellow]⚠️  .gitignore not configured for bmad-assist[/yellow]")
    console.print(f"   Missing patterns: {', '.join(missing)}")
    console.print("\n   To fix: [bold]bmad-assist init[/bold]")
    console.print("   To suppress: Add to [bold]bmad-assist.yaml[/bold]:")
    console.print("     [dim]warnings:[/dim]")
    console.print("     [dim]  suppress_gitignore: true[/dim]\n")


def copy_bundled_workflows(
    project_path: Path,
    force: bool,
    console: Console,
) -> CopyResult:
    """Copy all bundled workflows to project.

    Args:
        project_path: Project root directory.
        force: If True, overwrite differing files without prompts.
        console: Rich console for output.

    Returns:
        CopyResult with lists of copied, skipped, and unchanged workflows.

    """
    from bmad_assist.workflows import get_bundled_workflow_dir, list_bundled_workflows

    workflows = list_bundled_workflows()
    target_base = project_path / "_bmad" / "bmm" / "workflows" / "4-implementation"
    result = CopyResult()

    console.print(f"\n[bold]Checking {len(workflows)} bundled workflows...[/bold]")

    differing_workflows: list[tuple[str, Path, Path]] = []

    # Phase 1: Scan all workflows
    for i, name in enumerate(workflows, 1):
        console.print(f"  [{i}/{len(workflows)}] {name}...", end=" ")
        src_dir = get_bundled_workflow_dir(name)
        if src_dir is None:
            console.print("[red]NOT FOUND[/red]")
            continue

        dst_dir = target_base / name

        # Validate path safety (F3-SEC)
        if not _validate_path_safe(project_path, dst_dir):
            console.print("[red]SKIPPED (invalid path)[/red]")
            continue

        if not dst_dir.exists():
            _copy_workflow_tree(src_dir, dst_dir)
            console.print("[green]copied[/green]")
            result.copied.append(name)
        elif _workflow_dirs_identical(src_dir, dst_dir):
            console.print("[dim]unchanged[/dim]")
            result.unchanged.append(name)
        else:
            console.print("[yellow]differs[/yellow]")
            differing_workflows.append((name, src_dir, dst_dir))

    # Phase 2: Handle differing workflows
    if differing_workflows:
        if force:
            # Force mode: overwrite all without prompts
            for name, src_dir, dst_dir in differing_workflows:
                _copy_workflow_tree(src_dir, dst_dir)
                result.copied.append(name)
                console.print(f"  [green]Overwrote:[/green] {name}")
        else:
            # Collect all differing files across all workflows
            all_differing_files: list[tuple[Path, Path]] = []
            workflow_files_map: dict[str, list[tuple[Path, Path]]] = {}

            for name, src_dir, dst_dir in differing_workflows:
                files = _collect_differing_files(src_dir, dst_dir)
                if files:
                    all_differing_files.extend(files)
                    workflow_files_map[name] = files

            if all_differing_files:
                decision = _prompt_overwrite_batch(all_differing_files, console)

                if decision == OverwriteDecision.ALL:
                    # Overwrite all differing workflows
                    for name, src_dir, dst_dir in differing_workflows:
                        _copy_workflow_tree(src_dir, dst_dir)
                        result.copied.append(name)
                        console.print(f"  [green]Overwrote:[/green] {name}")
                elif decision == OverwriteDecision.SKIP:
                    # Skip all
                    for name, _, _ in differing_workflows:
                        result.skipped.append(name)
                elif decision == OverwriteDecision.INTERACTIVE:
                    # Interactive mode - prompt per file
                    for name, _src_dir, _dst_dir in differing_workflows:
                        files = workflow_files_map.get(name, [])
                        all_overwritten = True
                        for src_file, dst_file in files:
                            if _prompt_overwrite_single(src_file, dst_file, console):
                                _atomic_copy_file(src_file, dst_file)
                            else:
                                all_overwritten = False
                        if all_overwritten:
                            result.copied.append(name)
                        else:
                            result.skipped.append(name)
            else:
                # No actual file differences (edge case)
                for name, _, _ in differing_workflows:
                    result.unchanged.append(name)

    return result


def ensure_project_setup(
    project_path: Path,
    include_gitignore: bool = False,
    force: bool = False,
    console: Console | None = None,
) -> SetupResult:
    """Ensure project is set up for bmad-assist.

    Args:
        project_path: Project root directory.
        include_gitignore: If True, also update .gitignore (init only).
        force: If True, overwrite differing files without prompts.
        console: Rich console for output (None = no output).

    Returns:
        SetupResult with status and details.

    """
    from bmad_assist.git import setup_gitignore

    console = console or Console(quiet=True)
    result = SetupResult()

    # 1. Create .bmad-assist/ directory
    bmad_assist_dir = project_path / ".bmad-assist"
    if not bmad_assist_dir.exists():
        bmad_assist_dir.mkdir(parents=True)
        (bmad_assist_dir / "cache").mkdir()
        result.dirs_created.append(bmad_assist_dir)
        console.print(f"  [green]Created:[/green] {bmad_assist_dir.relative_to(project_path)}/")
    else:
        # Ensure cache subdir exists
        cache_dir = bmad_assist_dir / "cache"
        if not cache_dir.exists():
            cache_dir.mkdir()

    # 2. Create BMAD config if missing
    if _create_bmad_config(project_path, console):
        result.config_created = True

    # 3. Copy bundled workflows
    copy_result = copy_bundled_workflows(project_path, force, console)
    result.workflows_copied = copy_result.copied
    result.workflows_skipped = copy_result.skipped

    # 4. Setup gitignore (init only)
    if include_gitignore:
        changed, msg = setup_gitignore(project_path)
        result.gitignore_updated = changed
        if changed:
            console.print(f"  [green].gitignore:[/green] {msg}")

    return result
