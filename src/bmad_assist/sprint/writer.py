"""Atomic writer for sprint-status files with comment preservation.

This module implements an atomic writer for sprint-status.yaml files that:
- Uses temp file + os.replace() for crash resilience (same as core/state.py)
- Preserves YAML inline comments using ruamel.yaml (required dependency)
- Maintains entry ordering from SprintStatus.entries dict

Public API:
    - has_ruamel: Check if ruamel.yaml is available (always True since required)
    - write_sprint_status: Main entry point for atomic sprint-status writes
"""

from __future__ import annotations

import logging
import os
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any

import yaml

from bmad_assist.core.exceptions import StateError
from bmad_assist.sprint.models import SprintStatus

if TYPE_CHECKING:
    from ruamel.yaml.comments import CommentedMap

logger = logging.getLogger(__name__)

__all__ = [
    "has_ruamel",
    "write_sprint_status",
    # Internal helpers exported for testing
    "_load_with_comments",
    "_build_output_data",
    "_extract_epic_id",
    "_add_epic_comments",
    "_write_with_ruamel",
    "_write_with_pyyaml",
]

# Suffix for temporary files during atomic write (matches core/state.py)
TEMP_FILE_SUFFIX = ".tmp"

# Header comment for generated files
HEADER_TEMPLATE = """# Generated by bmad-assist on {timestamp}
# Sprint Status File - {project}
#
"""

# =============================================================================
# ruamel.yaml Verification (required dependency)
# =============================================================================


def _verify_ruamel() -> None:
    """Verify ruamel.yaml is installed (required dependency).

    Raises:
        ImportError: If ruamel.yaml is not available.

    """
    try:
        from ruamel.yaml import YAML  # noqa: F401
        from ruamel.yaml.comments import CommentedMap  # noqa: F401
    except ImportError as e:
        raise ImportError(
            "ruamel.yaml is required for YAML comment preservation. "
            "Install with: pip install 'ruamel.yaml>=0.18.0,<1.0.0'"
        ) from e


# Verify at module load time - fail fast if not available
_verify_ruamel()


def has_ruamel() -> bool:
    """Check if ruamel.yaml is available for comment preservation.

    Returns:
        True (always, since ruamel.yaml is now a required dependency).

    Note:
        This function is kept for backwards compatibility.
        Since ruamel.yaml is now required, it always returns True.

    """
    return True


# =============================================================================
# Comment Loading (Task 4)
# =============================================================================


def _load_with_comments(path: Path) -> tuple[dict[str, Any] | None, dict[str, str]]:
    """Load YAML file preserving comments using ruamel.yaml.

    When ruamel.yaml is available, loads the file in round-trip mode to
    preserve all comments. Extracts inline comments for entries in
    development_status section.

    Args:
        path: Path to YAML file to load.

    Returns:
        Tuple of (loaded_data, comments_dict).
        - loaded_data: CommentedMap if ruamel available, None otherwise
        - comments_dict: Dict mapping entry keys to their inline comments

    Note:
        If ruamel.yaml is unavailable or file doesn't exist, returns (None, {}).

    """
    comments: dict[str, str] = {}

    if not has_ruamel():
        return None, comments

    if not path.exists():
        return None, comments

    try:
        from ruamel.yaml import YAML
        from ruamel.yaml.comments import CommentedMap

        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True

        with open(path, encoding="utf-8") as f:
            data = yaml_rt.load(f)

        if data is None or not isinstance(data, CommentedMap):
            return None, comments

        # Extract inline comments from development_status entries
        dev_status = data.get("development_status")
        if (
            dev_status is not None
            and isinstance(dev_status, CommentedMap)
            and hasattr(dev_status, "ca")
            and hasattr(dev_status.ca, "items")
        ):
            # ruamel stores comments in .ca (Comment Attribute) structure
            # ca.items[key] contains tuples: (pre-comment, inline-comment, ...)
            for key in dev_status:
                    comment_token = dev_status.ca.items.get(key)
                    if comment_token is not None:
                        # Structure: [pre_comment, inline_comment, post_comment, ...]
                        # inline_comment is at index 2 (after key and value positions)
                        inline = comment_token[2] if len(comment_token) > 2 else None
                        if inline is not None:
                            # CommentToken has .value attribute with the actual comment
                            comment_text = getattr(inline, "value", None)
                            if comment_text:
                                # Strip leading # and whitespace
                                comment_str = str(comment_text).lstrip("# \t").rstrip()
                                if comment_str:
                                    comments[str(key)] = comment_str

        return data, comments

    except Exception as e:
        # Any error in ruamel parsing - fall back gracefully
        logger.warning("Failed to load with ruamel.yaml: %s", e)
        return None, comments


# =============================================================================
# Output Data Building (Task 5)
# =============================================================================


def _build_output_data(
    status: SprintStatus,
    original_comments: dict[str, str],
) -> dict[str, Any]:
    """Build output data structure from SprintStatus model.

    Constructs the YAML-serializable dict structure preserving entry ordering
    from the SprintStatus.entries dict.

    Args:
        status: SprintStatus model to serialize.
        original_comments: Dict of entry keys to inline comments (for logging).

    Returns:
        Dict ready for YAML serialization.

    """
    # Build metadata section
    data: dict[str, Any] = {
        "generated": status.metadata.generated.isoformat(),
    }

    # Add optional metadata fields if present
    if status.metadata.project:
        data["project"] = status.metadata.project
    if status.metadata.project_key:
        data["project_key"] = status.metadata.project_key
    if status.metadata.tracking_system:
        data["tracking_system"] = status.metadata.tracking_system
    if status.metadata.story_location:
        data["story_location"] = status.metadata.story_location

    # Build development_status section preserving entry order
    dev_status: dict[str, str] = {}
    for key, entry in status.entries.items():
        dev_status[key] = entry.status

    data["development_status"] = dev_status

    # Log comment preservation stats if we had original comments
    if original_comments:
        preserved = sum(1 for k in dev_status if k in original_comments)
        lost = len(original_comments) - preserved
        if lost > 0:
            logger.debug(
                "Comment preservation: %d preserved, %d lost (entries removed)",
                preserved,
                lost,
            )

    return data


# =============================================================================
# Epic Comment Helpers
# =============================================================================


def _extract_epic_id(key: str) -> str | int | None:
    """Extract epic ID from sprint-status key for comment grouping.

    Args:
        key: Sprint-status entry key.

    Returns:
        Epic ID (int for numeric, str for string epics), or None if standalone.

    Examples:
        >>> _extract_epic_id("epic-12")
        12
        >>> _extract_epic_id("12-3-setup")
        12
        >>> _extract_epic_id("epic-12-retrospective")
        12
        >>> _extract_epic_id("testarch-1-config")
        'testarch'
        >>> _extract_epic_id("standalone-01-refactor")
        None

    """
    import re

    # Standalone entries don't belong to an epic
    if key.startswith("standalone-"):
        return None

    # epic-X or epic-X-retrospective pattern
    if key.startswith("epic-"):
        rest = key[5:]  # Remove "epic-" prefix
        if "-retrospective" in rest:
            rest = rest.replace("-retrospective", "")
        try:
            return int(rest)
        except ValueError:
            return rest

    # Story pattern: X-Y-slug
    match = re.match(r"^([a-z0-9][a-z0-9-]*?)-(\d+)(?:-|$)", key, re.IGNORECASE)
    if match:
        epic_str = match.group(1)
        try:
            return int(epic_str)
        except ValueError:
            return epic_str

    return None


def _add_epic_comments(dev_status: CommentedMap) -> None:
    """Add epic separator comments to development_status CommentedMap.

    Adds `# Epic X` comment before the first entry of each epic group.
    Modifies dev_status in place.

    IMPORTANT: First clears any existing 'before' comments to prevent
    duplicate comments accumulating on each write (ruamel preserves
    comments from original file, so we must clear before re-adding).

    Args:
        dev_status: CommentedMap of development_status entries.

    """
    # Clear existing 'before' comments to prevent duplicates
    # ruamel stores comments in complex ways:
    # 1. ca.comment[1] - list of CommentTokens before the FIRST key in section
    # 2. ca.items[key][1] - list of CommentTokens before this key
    # 3. ca.items[key][2] - CommentToken for comments AFTER this key (which appear
    #                       visually before the NEXT key in the file)
    #
    # The yaml_set_comment_before_after_key() method adds to ca.items[key][1],
    # but when ruamel loads a file, comments between keys may be stored as
    # post-comments on the preceding key (index 2), not pre-comments on the
    # following key (index 1). We must clear both to prevent accumulation.
    if hasattr(dev_status, "ca"):
        # Clear section-level "before" comment (for first key)
        # ca.comment[1] is a list - must clear the list, not set to None
        if (
            hasattr(dev_status.ca, "comment")
            and dev_status.ca.comment
            and len(dev_status.ca.comment) > 1
            and isinstance(dev_status.ca.comment[1], list)
        ):
            dev_status.ca.comment[1].clear()

        # Clear per-key comments (both before [1] and after [2])
        if hasattr(dev_status.ca, "items"):
            for key in dev_status:
                if key in dev_status.ca.items:
                    comment_tuple = dev_status.ca.items[key]
                    if comment_tuple:
                        # Convert to list for modification
                        comment_list = list(comment_tuple)
                        modified = False

                        # Clear 'before' comments (index 1)
                        if len(comment_list) > 1 and isinstance(comment_list[1], list):
                            comment_list[1].clear()
                            modified = True

                        # Clear 'after/post' comments (index 2) - these appear
                        # visually before the NEXT key, so epic comments end up here
                        if len(comment_list) > 2 and comment_list[2] is not None:
                            comment_list[2] = None
                            modified = True

                        if modified:
                            dev_status.ca.items[key] = tuple(comment_list)

    current_epic: str | int | None = None

    for key in dev_status:
        epic_id = _extract_epic_id(key)
        if epic_id != current_epic and epic_id is not None:
            # Add comment before this entry - ruamel adds "# " prefix automatically
            # Use indent=2 to align with the YAML structure
            dev_status.yaml_set_comment_before_after_key(
                key, before=f"Epic {epic_id}", indent=2
            )
            current_epic = epic_id


# =============================================================================
# ruamel.yaml Writer (Task 6)
# =============================================================================


def _write_with_ruamel(
    data: dict[str, Any],
    original_data: CommentedMap | None,
    comments: dict[str, str],
    path: Path,
    project: str | None,
) -> None:
    """Write sprint-status using ruamel.yaml with comment preservation.

    Uses ruamel.yaml round-trip mode to preserve comments. When original_data
    is available, updates it in-place to preserve all comment associations.

    Note: The ruamel.yaml comment API is internal and may change between versions.
    This implementation uses the simplest approach: update values in-place in
    the original CommentedMap to preserve associated comments automatically.
    When creating new structures, comments are not manually re-attached to avoid
    relying on internal API that may change.

    Args:
        data: New data to write.
        original_data: Original CommentedMap if available (for in-place updates).
        comments: Dict of entry keys to inline comments (unused when original_data is None).
        path: Target file path.
        project: Project name for header comment.

    Raises:
        StateError: If write operation fails.

    """
    from ruamel.yaml import YAML
    from ruamel.yaml.comments import CommentedMap

    temp_path = path.with_suffix(path.suffix + TEMP_FILE_SUFFIX)

    try:
        yaml_rt = YAML(typ="rt")
        yaml_rt.preserve_quotes = True
        yaml_rt.default_flow_style = False

        # Decide whether to update in-place or build new structure
        if original_data is not None:
            output_data = original_data

            # Update metadata fields in-place
            output_data["generated"] = data["generated"]
            for meta_key in ["project", "project_key", "tracking_system", "story_location"]:
                if meta_key in data:
                    output_data[meta_key] = data[meta_key]
                elif meta_key in output_data:
                    del output_data[meta_key]

            # Get or create development_status
            if "development_status" not in output_data:
                output_data["development_status"] = CommentedMap()

            dev_status = output_data["development_status"]

            # Get current keys and new keys
            old_keys = set(dev_status.keys())
            new_data_dev = data.get("development_status", {})
            new_keys = set(new_data_dev.keys())

            # Remove entries not in new data
            for key in old_keys - new_keys:
                del dev_status[key]

            # Update/add entries from new data (in-place preserves comments)
            for key, value in new_data_dev.items():
                dev_status[key] = value

            # Re-order keys to match model's entry order (AC3)
            # move_to_end(last=True) moves each key to end in sequence,
            # resulting in the same order as new_data_dev
            for key in new_data_dev:
                if key in dev_status:
                    dev_status.move_to_end(key, last=True)

        else:
            # Build new CommentedMap structure (comments won't be preserved
            # since we don't have original data to update in-place)
            output_data = CommentedMap()

            # Add metadata
            output_data["generated"] = data["generated"]
            for meta_key in ["project", "project_key", "tracking_system", "story_location"]:
                if meta_key in data:
                    output_data[meta_key] = data[meta_key]

            # Add development_status
            dev_status = CommentedMap()
            for key, value in data.get("development_status", {}).items():
                dev_status[key] = value
            output_data["development_status"] = dev_status

            # Note: We don't manually re-attach comments here to avoid relying
            # on internal ruamel.yaml API that changes between versions.
            # Comment preservation only works when updating existing files.

        # Add epic separator comments (# Epic X) before each epic group
        _add_epic_comments(dev_status)

        # Add header comment
        timestamp = datetime.now(UTC).replace(tzinfo=None).isoformat(timespec="seconds")
        header = HEADER_TEMPLATE.format(timestamp=timestamp, project=project or "unknown")
        output_data.yaml_set_start_comment(header)

        # Create parent directories if missing
        path.parent.mkdir(parents=True, exist_ok=True)

        # Write to temp file
        with open(temp_path, "w", encoding="utf-8") as f:
            yaml_rt.dump(output_data, f)

        # Atomic replace
        os.replace(temp_path, path)

    except OSError as e:
        # Attempt cleanup but don't fail if we can't check/delete
        try:
            if temp_path.exists():
                temp_path.unlink()
        except OSError:
            pass  # Best-effort cleanup
        raise StateError(f"Failed to write sprint-status to {path}: {e}") from e


# =============================================================================
# PyYAML Fallback Writer (Task 7)
# =============================================================================


def _write_with_pyyaml(
    data: dict[str, Any],
    path: Path,
    project: str | None,
) -> None:
    """Write sprint-status using PyYAML (no comment preservation).

    Fallback writer when ruamel.yaml is unavailable. Comments from the
    original file will be lost.

    Args:
        data: Data to write.
        path: Target file path.
        project: Project name for header comment.

    Raises:
        StateError: If write operation fails.

    """
    temp_path = path.with_suffix(path.suffix + TEMP_FILE_SUFFIX)

    try:
        # Create parent directories if missing
        path.parent.mkdir(parents=True, exist_ok=True)

        # Build content with header
        timestamp = datetime.now(UTC).replace(tzinfo=None).isoformat(timespec="seconds")
        header = HEADER_TEMPLATE.format(timestamp=timestamp, project=project or "unknown")

        yaml_content = yaml.dump(
            data,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True,
        )

        # Write to temp file
        with open(temp_path, "w", encoding="utf-8") as f:
            f.write(header)
            f.write(yaml_content)

        # Atomic replace
        os.replace(temp_path, path)

    except OSError as e:
        # Attempt cleanup but don't fail if we can't check/delete
        try:
            if temp_path.exists():
                temp_path.unlink()
        except OSError:
            pass  # Best-effort cleanup
        raise StateError(f"Failed to write sprint-status to {path}: {e}") from e


# =============================================================================
# Main Write Function (Task 8)
# =============================================================================


def write_sprint_status(
    status: SprintStatus,
    path: Path | str,
    preserve_comments: bool = True,
) -> None:
    """Write sprint-status to YAML with optional comment preservation.

    Uses ruamel.yaml for round-trip comment preservation when available.
    Falls back to PyYAML (comments lost) when ruamel unavailable.

    The write is atomic: uses temp file + os.replace() to ensure crash
    resilience. Previous valid state is never corrupted by partial writes.

    Args:
        status: SprintStatus model to write.
        path: Target file path (str or Path). Tilde (~) is expanded.
        preserve_comments: If True and ruamel available, preserve inline
            comments from original file. Default True.

    Raises:
        StateError: If write operation fails.

    Example:
        >>> from bmad_assist.sprint.writer import write_sprint_status
        >>> from bmad_assist.sprint.models import SprintStatus
        >>> status = SprintStatus.empty("my-project")
        >>> write_sprint_status(status, Path("sprint-status.yaml"))

    Note:
        - If file doesn't exist, creates new file without comments
        - Entry ordering is preserved from status.entries dict
        - Comments for removed entries are silently dropped

    """
    path = Path(path).expanduser()
    project = status.metadata.project

    # Load original comments if requested and ruamel available
    original_data: CommentedMap | None = None
    comments: dict[str, str] = {}

    if preserve_comments and has_ruamel() and path.exists():
        original_data_result, comments = _load_with_comments(path)
        if original_data_result is not None:
            # Cast for type checking - we verified ruamel is available
            from ruamel.yaml.comments import CommentedMap

            if isinstance(original_data_result, CommentedMap):
                original_data = original_data_result

    # Build output data structure
    data = _build_output_data(status, comments)

    # Choose backend - ruamel.yaml is required, so always use it when preserving comments
    if preserve_comments:
        logger.debug("Writing sprint-status with ruamel.yaml (comment preservation)")
        _write_with_ruamel(data, original_data, comments, path, project)
    else:
        # User explicitly disabled comment preservation
        _write_with_pyyaml(data, path, project)
